6.5 Практическая работа
Цель домашнего задания
В этом модуле мы увидели, как работать с постоянными хранилищами, и узнали про объекты с сохранением состояния StatefulSet. Цель этой домашней работы — попрактиковаться в подключении постоянных хранилищ к подам с помощью объекта StorageClass и на практике увидеть преимущества StatefulSet для приложений с сохранением состояния.



Что входит в задание
Настроить сохранение данных в случае перезапуска базы.
Использовать StatefulSet вместо используемого ранее Deployment.


Введение
Ваша команда продолжает разрабатывать REST-сервис billing — приложение на Python, сохраняющее историю платежей пользователей в базу postgres. База находится в кластере в том же неймспейсе, что и само приложение, и недоступна снаружи кластера. 

Приложение представляет собой веб-сервер на Flask, «слушающий» на порту 8080 и имеющий следующие эндпоинты:

GET:

/ping — возвращает строку pong;
/getall — возвращает список всех записей в базе;
/get/<id> — возвращает запись по конкретному id.
POST:

/add — создаёт новую запись. Параметры запроса:
client_id — id клиента;
amount — размер платежа.
Примеры запросов :

```
curl http://127.0.0.1:8080/getall  ### Запрашивает все записи в базе
curl http://127.0.0.1:8080/get/1   ### Запрашивает запись с id 1
curl -X POST http://127.0.0.1:8080/add?client_id=1\&amount=100
```
### Создает новую запись с client_id=1 и amount=100


Задание 1. Сохранение данных в случае перезапуска базы
После случайного перезапуска пода с postgres база запустилась чистой, и все проведённые тестовые транзакции были потеряны. QA-инженер попросил вас настроить сохранение данных в случае перезапуска базы.



Что нужно сделать

Создайте новые объекты StorageClass и PersistentVolumeClaim и настройте автоматическое создание и подключение постоянного хранилища к поду с базой приложения.

Для этого:

Разверните приложение в кластере.

Перейдите в GitLab Skillbox по кнопке внизу.
В папке module-6/Homework/task-1/billing/app находится приложение billing. 
Соберите приложение:
`docker build -t billing:v1.1 .`
Загрузите полученный образ в ваш Docker Registry. В случае с Minikube это можно сделать так:
`minikube image load billing:v1.1`
В директории module-6/Homework/task-1/billing находятся манифесты деплойментов базы, самого приложения и их сервисы. Создайте объекты в кластере:
```
kubectl create -f db.yaml
kubectl create -f app.yaml
```
Проверьте, что сервис корректно запустился и работает. Для этого создайте рядом вспомогательный pod:
```
kubectl run tmp-pod --rm -i --tty --image 
nicolaka/netshoot -- /bin/bash
```
И протестируйте его эндпоинты:
Создайте новую транзакцию командой:
`curl -X POST http://billing:8080/add?client_id=1\&amount=1000`
И запросите её детальную информацию:
`curl http://billing:8080/get/1`
Теперь удалите под с базой:
`kubectl delete pod -l app=postgres`
    Так как база управляется объектом деплоймента, то под будет пересоздан. 

После запуска нового пода с базой (это может занять  ~1-2 минуты) попробуйте получить список всех транзакций из временного пода netshoot:
`bash-5.1# curl http://billing:8080/getall`
Вы увидите такую ошибку:

`(psycopg2.errors.UndefinedTable) relation "transactions" does not exist`
    Почему она возникла? Мы перезапустили базу, которая хранила все файлы данных в файловой системе пода, и после его пересоздания все её данные удалились. Поэтому приложение и не может найти нужную таблицу transactions.

Чтобы избежать потери данных в будущем, настройте подключение постоянного хранилища к БД. Для этого создайте следующие объекты:

объект StorageClass с параметрами:
```
reclaimPolicy: Retain
allowVolumeExpansion: true
volumeBindingMode: Immediate
```
provisioner: зависит от того, где у вас развёрнут Kubernetes-кластер, для «Миникуба» это k8s.io/minikube-hostpath

объект PersistentVolumeClaim с параметрами:
```
accessModes: ReadWriteOnce
storage: 1Gi
```
Обратите внимание, что PersistentVolumeClaim должен использовать только что созданный StorageClass.

И добавьте созданный persistentVolumeClaim в манифест деплоймента базы.

Убедитесь, что хранилище сконфигурировано верно. Для этого снова удалите под с базой и проверьте, что все сохранённые транзакции на месте.


Что оценивается

Корректность манифестов StorageClass, PersistentVolumeClaim и Postgres Deployment.



Как отправить задание на проверку

Пришлите YAML-файлы с манифестом сервиса через форму ниже.



Задание 2. Использование StatefulSet вместо Deployment
Разработчики собираются обновить сервис billing, сделав его распределённым с сохранением состояния. Для реализации этой задачи на первом шаге они добавили в приложение дополнительную логику: при создании новой транзакции в лог-файл пишется хостнейм пода, который обработал транзакцию, и детали самой транзакции. К примеру, файл /var/log/app.log будет содержать следующие строки:
```
2021-09-19 20:57:01: host billing-stateful-0, client 1, amount 1000
2021-09-19 21:24:07: host billing-stateful-0, client 2, amount 2000
```
… 

Но при тестировании новой функциональности разработчики столкнулись со следующими проблемами:

Нет возможности послать запрос на конкретный под деплоймента.
При пересоздании подов их сетевые имена меняются.
При монтировании постоянного хранилища все реплики приложения писали в один файл, и логи смешивались. У каждого пода должно быть своё собственное постоянное хранилище; нельзя, чтобы логи транзакций разных подов смешивались друг с другом.
Чтобы решить эти проблемы, вы предлагаете использовать StatefulSet вместо используемого ранее Deployment.



Что нужно сделать

Создайте StatefuleSet и Headless service для приложения billing.

Для этого:

Пересоберите новую версию приложения с тегом 2.0:

В папке module-6/Homework/task-2/billing-v2.0/app находится приложение billing. 
Соберите приложение:
`docker build -t billing:v2.0 .`
Загрузите полученный образ в ваш Docker Registry. В случае с Minikube это можно сделать так:
`minikube image load billing:v2.0`
В директории module-6/Homework/task-2/billing-v2.0 находится манифест деплоймента базы и её сервис. Создайте объекты в кластере:
`kubectl create -f db.yaml`
Для решения поставленной разработчиками задачи создайте два объекта Kubernetes:

StatefulSet для приложения billing со следующими параметрами:
```
volumeClaimTemplates:
accessModes: ReadWriteOnce
storage: 1Gi
```
Headless service вместо стандартного ClusterIP-сервиса.


Hint: в файле module-6/Homework/task-2/billing-v2.0/app-template.yaml вы можете найти заготовки этих объектов. Вам нужно будет добавить поле volumeClaimTemplates к объекту StatefulSet и поменять тип billing-stateful сервиса на headless.



Проверьте, что сервис корректно запустился и работает. Для этого создайте рядом вспомогательный pod:
```
kubectl run tmp-pod --rm -i --tty --image 
nicolaka/netshoot -- /bin/bash
```
И протестируйте из него эндпоинты новых stateful-подов:
```
curl -X POST http://billing-stateful-0.billing-stateful.default.svc.cluster.local:8080/add?client_id=1\&amount=1000 
curl -X POST http://billing-stateful-1.billing-stateful.default.svc.cluster.local:8080/add?client_id=1\&amount=1000 
curl -X POST http://billing-stateful-2.billing-stateful.default.svc.cluster.local:8080/add?client_id=1\&amount=1000 
```
В лог-файлах подов должны появиться записи:
```
bash-5.1# for i in 0 1 2; do kubectl exec -ti billing-stateful-$i
 -c billing -- cat /var/log/app.log ; done

2021-09-19 20:57:01: host billing-stateful-0, client 1, amount 1000 
2021-09-19 20:57:06: host billing-stateful-1, client 1, amount 1000 
2021-09-19 20:57:14: host billing-stateful-2, client 1, amount 1000 
```
Чтобы проверить, что постоянные хранилища подключены корректно, удалите одну из реплик statefulset. 

`bash-5.1# kubectl delete pod billing-stateful-2`
После её пересоздания проверьте файлы в директории вновь созданного пода:

```
bash-5.1# kubectl exec -ti billing-stateful-2 -c billing -- cat /var/log/app.log
```
Там должны находиться файлы, сохранённые ещё до удаления прошлой репликой:

`2021-09-19 20:57:14: host billing-stateful-2, client 1, amount 1000`