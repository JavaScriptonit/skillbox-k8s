# 8.5 Практическая работа

## Цель домашнего задания
В этом модуле вы познакомились с запросами и лимитами ресурсов, способами ограничивать их для пода и всего неймспейса и узнали про способы автомасштабирования в Kubernetes. Цель этой домашней работы — попрактиковаться в назначении и лимитировании ресурсов подов, а также настроить автомасштабирование на основе потребления cpu. 



## Что входит в домашнее задание
Назначить приложению ресурсные запросы и лимиты.
Ограничить диапазон потребления ресурсов с помощью объектов LimitRange и ResourceQuota.
Настроить горизонтальное масштабирование приложения.


## Подготовка окружения
Все задания мы будем выполнять с приложением billing, поэтому нам нужно собрать и установить его в кластере. Для этого:

Перейдите в GitLab Skillbox по кнопке внизу.
В папке module-8/Homework/billing/app находится приложение billing. 
Соберите приложение:
docker build -t server:v1.8 .
Загрузите полученный образ в ваш Docker Registry. В случае с Minikube это можно сделать так:
minikube image load server:v1.8
В директории module-8/Homework/billingнаходятся манифесты деплоймента и сервиса базы. Создайте объекты в кластере:
kubectl create -f db.yaml


## Задание 1. Назначить приложению необходимые ресурсные запросы и лимиты
Что нужно сделать

Вы заметили, что поды приложения billing периодически недоступны и перезагружаются. После выяснения причин оказалось, что они убиваются OOM-киллером при нехватке памяти, а также что у приложения не установлены запросы ресурсов и лимиты, поэтому Kubernetes scheduler периодически назначал их на ноды с недостаточным количеством ресурсов. Вы решаете установить запросы и лимиты контейнера в поде таким образом, чтобы под получил QoS-класс guaranteed и в случае нехватки ресурсов на ноде был убит в последнюю очередь. Для этого:

В папке module-8/Homework/task1/app находится манифест объектов приложения billing. Задайте в объекте Deployment следующие параметры resource requests:
cpu: 500m
memory: 512Mi
        и соответствующие им resource limits таким образом, чтобы под получил статус guaranteed. Hint: не забудьте про init-контейнер. Ему можно установить запросы и лимиты на ваш выбор.

Создайте приложение из обновлённого манифеста. Проверить, что под получил нужный класс QoS, можно командой:
`kubectl get pods -o=jsonpath='{range .items[*]}{.metadata.name}{"\t"}{.status.qosClass}{"\n"}{end}' `





## Задание 2. Ограничить потребление ресурсов, используя объекты LimitRange и ResourceQuota
Чтобы оптимизировать использование ресурсов в кластере и исключить возможные ошибки конфигурации, вы решаете установить диапазон возможных ресурсных запросов для приложения и ограничить общее число реплик подов для неймспейса. Для этих целей хорошо подходят объекты LimitRange и ResourceQuota. 



Что нужно сделать

Задайте следующий возможный диапазон ресурсных запросов для контейнеров подов неймспейса с помощью объекта LimitRange:
cpu: 100m ‒ 1
memory: 100Mi ‒ 1Gi
        Hint: чтобы протестировать корректность работы LimitRange, можно задать значения ресурсных запросов приложения, которые выходят за пределы допустимого диапазона. Проще всего сделать это, пропатчив текущий деплоймент с помощью команды kubectl patch. Файл патча ресурсов находится в папке module-8/Homework/task2:

`kubectl patch deployment billing --patch "$(cat deployment-resource-patch.yaml)"`
        Деплоймент создаст новый объект replicaSet, поды которого не смогут запуститься из-за превышения запрашиваемых ресурсов.

Задайте максимальное число подов неймспейса с помощью объекта ResourceQuota:
pods: "5"
        Протестировать ResourceQuota можно, попробовав отмасштабировать число реплик приложения до 10 и посмотреть на число реально созданных подов:

`kubectl scale deployment billing --replicas 10`





## Задание 3. Настроить горизонтальное масштабирование подов приложения.
Настройте HorizontalPodAutoscaler для приложения billing на основе потребления CPU.



Что нужно сделать

Удалите из кластера объекты LimitRange и ResourceQuota, созданные в задании 2.
Установите metrics-server в кластер. Для minikube это можно сделать командой:
`minikube addons enable metrics-server`
Примените манифест приложения app.yaml из папки module-8/Homework/task3:
`kubectl apply -f app.yaml`
На основе шаблона hpa.template создайте объект HPA со следующими параметрами:
min Replicas: 1
max Replicas: 5
CPU averageUtilization: 50%
        Hint: посмотреть примеры манифестов HPA можно здесь.

Для создания нагрузки для проверки работы HPA можно запустить нагрузочный скрипт из служебного контейнера, развёрнутого в том же неймспейсе.
        Для этого запустите служебный контейнер:

`kubectl run tmp-pod --rm -i --tty --image nicolaka/netshoot -- /bin/bash`
и вставьте текст скрипта из файла load.sh в bash внутри контейнера:

```
bash-5.1# cat <<EOT > script.sh

> #!/bin/bash

> for i in {1..10000}

> do

>   curl -s -o /dev/null -X POST http://billing:8080/add?client_id=&amount=1000

>   curl -s -o /dev/null http://billing:8080/getallt

> done

> EOT

bash-5.1# bash script.sh
```
